import math
import random
from array import *
from math import gcd as bltin_gcd
from fractions import Fraction
import matplotlib.pyplot as plt

import numpy as np
#import RationalMatrices as Qmtx

################################################################################
####################################################################################
    ###### Methods for Qmatrix #####
# --------------------------------------------
def printQmtx(M):
    print('(' , M[0,0],'   ', M[0,1], ')')
    print('(' , M[1,0],'   ', M[1,1], ')')
    return
    
# --------------------------------------------
def det(M):
    return M[0,0]*M[1,1]-M[1,0]*M[0,1]

# --------------------------------------------
def tr(M):
    return M[0,0]+M[1,1]


# --------------------------------------------
def multiply(N,M):
# Returns the product NM, each entry in N, M and NM is Fraction
    a1=M[0,0].numerator
    b1=M[0,0].denominator

    a2=M[0,1].numerator
    b2=M[0,1].denominator  

    a3=M[1,0].numerator
    b3=M[1,0].denominator
    
    a4=M[1,1].numerator
    b4=M[1,1].denominator
    
    c1=N[0,0].numerator
    d1=N[0,0].denominator

    c2=N[0,1].numerator
    d2=N[0,1].denominator  

    c3=N[1,0].numerator
    d3=N[1,0].denominator
    
    c4=N[1,1].numerator
    d4=N[1,1].denominator
    
    R00 = Fraction(a1*d2*c1*b3 + a3*b1*c2*d1 , d1*d2*b1*b3)
    R01 = Fraction(a2*c1*d2*b4 + c2*a4*b2*d1 , b2*d1*d2*b4)
    R10 = Fraction(a1*b3*c3*d4 + a3*b1*c4*d3 , d3*d4*b1*b3)
    R11 = Fraction(a2*c3*b4*d4 + c4*a4*b2*d3 , b2*b4*d3*d4)
    
    return np.matrix( [ (R00,R01)  , (R10, R11) ] )

# --------------------------------------------
def mult(k,M):
    a1=M[0,0].numerator
    b1=M[0,0].denominator

    a2=M[0,1].numerator
    b2=M[0,1].denominator  

    a3=M[1,0].numerator
    b3=M[1,0].denominator
    
    a4=M[1,1].numerator
    b4=M[1,1].denominator

    return np.matrix( [ (Fraction(k*a1,b1),Fraction(k*a2,b2)) , ( Fraction(k*a3,b3), Fraction(k*a4,b4))] )   

# --------------------------------------------
def inverse(M):
    a1=M[0,0].numerator
    b1=M[0,0].denominator

    a2=M[0,1].numerator
    b2=M[0,1].denominator  

    a3=M[1,0].numerator
    b3=M[1,0].denominator
    
    a4=M[1,1].numerator
    b4=M[1,1].denominator
    
    dnum = a1*a4*b2*b3-a2*a3*b1*b4 # Numerator and denominator of determinant
    ddem = b1*b2*b3*b4
    
    N = np.matrix([(Fraction(dnum*a4,ddem*b4) ,Fraction(-dnum*a2,ddem*b2)),(Fraction(-dnum*a3,ddem*b3) ,Fraction(dnum*a1,ddem*b1))])
    
    return N




    ####################################################################################
    ####################################################################################

    def mob_transf(M, a):
    # Mobius transofrmation associated to matrix M, where 
    # M has all type Fraction entries (rational)
    # a must be Fraction or string INF
    # a is assumed to be rational on x-axis (imaginary coord =0)
    # returns a Fraction or string INF if it sends a to oo    
       
    a1=M[0,0].numerator
    b1=M[0,0].denominator
    
        
    a3=M[1,0].numerator
    b3=M[1,0].denominator
    
    if( a == "INF"):
        if (a3 == 0):
            return "INF"
        else:
            return Fraction(a1*b3, a3*b1) 
    
    x=a.numerator
    y=a.denominator
 
    a4=M[1,1].numerator
    b4=M[1,1].denominator
    
    if (a3*b4*x + a4*b3*y) ==0:
        return "INF"
 
    a2=M[0,1].numerator
    b2=M[0,1].denominator
    
    
    #    print('type of matrix entry', type (M[0,0]))
    p=(b3*b4*y)*(a1*b2*x + a2*b1*y)
    q=(b1*b2*y)*(a3*b4*x + a4*b3*y)
#    print('p=',p)
#    print('q=',q)
#    return Decimal(p/q)
    return Fraction(p,q)


# --------------------------------------------
def sends2inf(M, a):
    # the type of both M and x is Fraction
    # x is assumed to be rational on (imaginary coord =0)
    # returns a Fraction
    x=a.numerator
    y=a.denominator
    
    a3=M[1,0].numerator
    b3=M[1,0].denominator
    
    a4=M[1,1].numerator
    b4=M[1,1].denominator
    
    if (a3*b4*x + a4*b3*y) ==0:
        return True
    else:
        return False
    
# --------------------------------------------
def toinfelement(M):
    
    a3=M[1,0].numerator
    b3=M[1,0].denominator
    
    a4=M[1,1].numerator
    b4=M[1,1].denominator

    return Fraction(-a4*b3,b4*a3)

####################################################################################
####################################################################################

class jigsawset:
    # the jigsaw will be formed with triangles from the jigsaw set
    # it only admits at most two different types of tiles.
    
    def __init__(self, tiles=[1,2], sign=[1,0]): 
        #Default jigsaw is generated by Delta(1,1,1) in canonical position
        jigsawset.tiles=tiles # types of the tiles 
        jigsawset.sign=sign   # number of tiles of each type
        
        #Length of fundamental interval of group generated by self
        jigsawset.L = l=self.sign[0]*(2+self.tiles[0]) +self.sign[1]*(2+self.tiles[1])

    def size(self): # numer of triangles in the jigsawset (with multiplicity)
        return self.sign[0]+self.sign[1]
 
    def print(self):
        print('************** JIGSAW.print ******************')
        print("tile types:", self.tiles)
        print("signature:", self.sign)
        print('************** ************ ******************')
        print('')


####################################################################################
####################################################################################

def Jigsaw_vertices(jigsawset): 
# Returns the x-coords of the vertices of the jigsaw formed by tiles glued from jigsawset 
# assuming they all have inf as a common vertex and a Delta(1) is in standard position
# Coords go from negative to positive.
# vertex at infinity is not included in the list
# Type of vertices is integer

    vertices=[-1,0]  #Jigsaw always has the tile [infty, -1,0]
    i=1
    while i<jigsawset.sign[0]:     #First glue all 1-tiles to the left (negative vertices)
        vertices.insert(0,-(i+1))
        i+=1 
    j=0
    while j<jigsawset.sign[1]:     #Then glue all n-tiles to the right (positive vertices)
        if (j%3 != 1):
            vertices.append(vertices[i]+1)
        if(j%3 ==1):
            vertices.append(vertices[i]+jigsawset.tiles[1])
        i+=1
        j+=1
    return vertices
# ################################################################################
        ###### TEST for Jigsaw_vertices #####
# JS= jigsawset([1,2],[4,6])
# JS.print()
# Jigsaw_vertices(JS)


################################################################################
################################################################################

# ......... rotation_info(n, v2,v3) .........
# Say (m,y) is the (unknown) point of rotation of the geodesic [v2,v3] with side type k,
# the function returns (m,y^2), m and y^2 are Fraction type
# This is done to have only integer values, since y is often a square root
# Uses proposition 4.3 to consider different cases according to side_type.
#     v2,v3 = vertices of ideal side, assumed to come from tiles of the type [infty, v2, v3]
#     n = type of the side [v2,v3]
#     isfrac = whether the distance of the rotation point from midpoint is n or 1/n, 
#              both are considered type n, so we need to specify if it is a fraction


def rotation_info(n,isfrac,v2,v3): #renamed from info_for_rotation
    l= v3-v2
    if(n==1):         
        #side_type==1 => edge [v2, v3] is a semi-circle of diameter n (n=type of triangle)
        return ( Fraction(2*v2+l,2) , Fraction(l*l,4) ) 
    
    if(isfrac == False): #Input n represents the integer n>1
        #side_type>1 => edge [v2, v3] is a semi-circle of diameter 1
        return ( Fraction(n+(1+n)*v2,1+n), Fraction(n,(1+n)*(1+n)) )
    
    if(isfrac == True): #Input n represents the fraction 1/n          
        #side_type>1 => edge [v2, v3] is a semi-circle of diameter 1
        return ( Fraction(1+(1+n)*v2,1+n), Fraction(n,(1+n)*(1+n)) )

    
################################################################################
################################################################################


def rotation_points(jigsawset): 
    #Given jigsaw set returns a list in CCW order with the rotation points on exterior sides
    # ** The y-coord of every point is the square of the actual coordinate **
    # renamed from info_rotation_points
    
    V = Jigsaw_vertices(jigsawset)
    
    #By construction first midpoint is on vertical side of a type 1 tile. 
    points=[(Fraction(V[0]),Fraction(1))]       
    i=0
    
    # Add all midpoints of type 1 tiles
    N=jigsawset.sign[0]
    while i<N:     
        points.append(rotation_info(1,0,V[i],V[i+1]))
        i+=1 
    
    # Now add all midpoints of type n tiles
    # taking gluing rotation into account (prop 4.3)
    
    N+=jigsawset.sign[1]    
    j=1
    while i<N:      
        if(j%3==1):
            type=jigsawset.tiles[1]
            isfrac= True
        if(j%3==2):
            type=1
            isfrac = False
        if(j%3==0):
            type=jigsawset.tiles[1]
            isfrac = False
        
        points.append(rotation_info(type,isfrac,V[i],V[i+1]))
        i+=1
        j+=1 
    
    # Last midpoint is from vertical side   
    if(jigsawset.sign[1]==0):
        points.append((Fraction(V[i]),Fraction(1)))
    
    else:     # The right vertical side of the last tile you glued (prop 4.3 - 5)
        j= j-1
        if(j%3==0):
            points.append( (Fraction(V[i]) , Fraction(1)) )
        else:
            points.append( (Fraction(V[i]) , Fraction(jigsawset.tiles[1],1)) )

    return points

# ################################################################################
#JS= jigsawset([1,2],[1,0])
#JS.print()

#R = rotation_points(JS)

#print('********* ROTATION POINTS WITH INFO *********')
#print('recall y-coord is the square of the actual coordinate')
#for i in range (0,JS.size()+2):
#    print('(' , R[i][0],',', R[i][1], ')')

#################################################################################
#################################################################################
def pi_rotation_special(x,y2):
    # Given the point (x,y^2) returns the matrix representing pi rotation about (x,y)
    # This can be calculated to be:
    #  ( -x   y^2+x^2 )
    #  ( -1     x    )
    # Matrix is in GL(2,Q) (det may not be 1). that's ok since we only use it as a mob transf
    # Coordinates of matrix are type Fraction, so assumes inputs are integers
    
    Rotation = np.matrix( [ (Fraction(-x),Fraction(y2+x*x))  , (Fraction(-1), Fraction(x))] )
    
    return Rotation  


#################################################################################
    ###### TEST FOR pi_rotation_special #####
# print('---------------')
# Q= pi_rotation_special(Fraction(-1,2),Fraction(1,4))  # <--- recall y is squared for this function
# printQmtx(Q)


#################################################################################
#################################################################################



def jigsaw_generators(jigsawset):
    # Returns a list TAU with the matrices that represent rotations around 
    # midpoints of exterior sides of jigsaw formed by jigsaw set
    # coordinates of the matrices are type Fraction
    # renamed from jigsaw_generators_Q
    
    P = rotation_points(jigsawset)
    N = jigsawset.size()
    TAU=[]
    for i in range (0, N+2):
        TAU.append(pi_rotation_special(P[i][0],P[i][1]))
    return TAU

################################################################################
    ###### TEST for jigsaw_generators #####
JS= jigsawset([1,2],[1,1])
JS.print()

Q = rotation_points(JS)

print('')

print('********* ROTATION POINTS WITH INFO *********')
print('recall y-coord is the square of the actual coordinate')
for i in range (0,JS.size()+2):
    print('(' , Q[i][0],',', Q[i][1], ')')
    
print('')

TAU = jigsaw_generators(JS)
    
print('')
print('**************************************************')
for i in range (0,JS.size() +2):
    print('rotation about', '(' , Q[i][0],',  sqrt(', Q[i][1], ')  ) ' , 'is')
    print('T',i, '=')
    printQmtx(TAU[i])
    print('***')
    

#################################################################################
#################################################################################


def calculateToInf(vertex,generator): 
    # Returns an array transf where 
    #     transf[i][0] =  sends vertex[i] to infinity
    # Not optimized
    
    transf = []
    n = len(generator)
    
    for i in range (0,n-1):   # There is one less vertex than generators
        word = 0
        M = np.matrix([(Fraction(1), Fraction(0)), (Fraction(0),Fraction(1))])
        for j in range (i+1,n):
            M = multiply(generator[j],M)
            word = (j+1)*10**(j-i-1) + word  # generators indices start from 1 when printed
        transf.append((M,word))
        #print(word)
        if(sends2inf(M,vertex[i]) == False):
           print('error', i)
        
    return transf


#################################################################################
#################################################################################


class JigsawGroup (object):
    def __init__(self, tiles=[1,2], sign=[1,0]): 
        #Default group is the one generated by canonical Delta(1,1,1)
        
        JigsawGroup.tiles = tiles
        JigsawGroup.sign = sign
        JigsawGroup.Jset = jigsawset(tiles,sign)
        
        # Following attributes are shared with WeirGroup class

        JigsawGroup.rank = sign[0]+sign[1]+2     #Generators = number of exterior sides of jigsaw
        JigsawGroup.vertices = Jigsaw_vertices(self.Jset)
        JigsawGroup.pts_Y2 = rotation_points(self.Jset)
        JigsawGroup.generators = jigsaw_generators(self.Jset)

        #? don't remember what this does
        JigsawGroup.RotationsToInf = calculateToInf(self.vertices, self.generators)

        #Length of fundamental interval of group, calculated using Lou, Tan & Vo 4.5
        JigsawGroup.L = self.Jset.sign[0]*(2+self.Jset.tiles[0]) +self.Jset.sign[1]*(2+self.Jset.tiles[1])
 
    def print(self):
        print(' ****** print Jigsaw Group ******')
        print(' ')
        print('This group comes from a jigsaw with ', self.sign[0],' tiles of type', self.tiles[0])
        print('                                 and', self.sign[1],'tiles of type', self.tiles[1],'.')
        print('Length of fund interval = ', self.L)
        print("Number of generators:",self.rank, '. These are:')
        print(' ')
        for i in range (0,self.rank):
            print('rotation about', '(' , self.pts_Y2[i][0],',  sqrt(', self.pts_Y2[i][1], ')  ) ' , 'is')
            print('T',i+1, '=')
            printQmtx(self.generators[i])
            #det=detQmatrix(self.generators[i])
            #print('det(T',i,')=', det)
            print('')
        print('The jigsaw has vertices (apart from oo):')
        for i in range(0, len(self.vertices)):
            print('(',self.vertices[i], ',0)')
        return 
    
    def printNOGENS(self):
        print(' ****** print Jigsaw Group ******')
        print(' ')
        print('This group comes from a jigsaw with ', self.sign[0],' tiles of type', self.tiles[0])
        print('                                 and', self.sign[1],'tiles of type', self.tiles[1],'.')
        print('Length of fund interval = ', self.L)
        print("Number of generators:",self.rank)
        print(' ')
        print('The jigsaw has vertices (apart from oo):')
        print(self.vertices)
        return
    
    def printSet(self):
        self.Jset.print()

################################################################################
    ##### CHECK Jigsawgroup class ####
JG= JigsawGroup([1,2],[1,1])
JG.print()

print('***********')
print('The words of the transformations that send vertices to oo')
for i in range (0,JG.rank-1):
    print(JG.RotationsToInf[i][1])

################################################################################
################################################################################

# SPECIAL EXAMPLE: WEIRSTRASS GROUPS

################################################################################
def generatorsWeirGroup(k1,k2,k3):
    # Calculates generators according to equation (2) in paper
    # Determinant may not be 1, and type of entries is Fraction
    T1 = np.matrix( [(k1, 1+k1),(-k1,-k1)])
    T2 = np.matrix( [(1, 1),(-k2-1,-1)])
    T3 = np.matrix( [(0, k3),(-1,0)])
    
    return [T1, T2, T3]

def info_rotation_points_Wgrp(k1,k2,k3): 
    # Given k1,k2,k3 Fractions, returns a list in CCW order with the rotation points on exterior sides
    # y-coordinate is squared to avoid floating point error
    # Calculations come from equation (1) in paper
    x1 = (Fraction(-1,1),Fraction(k1.denominator,k1.numerator))
    
    a2 = k2.numerator
    b2 = k2.denominator
    x2 = (Fraction(-b2,a2+b2), Fraction(b2*a2 , b2*b2+2*a2*b2+a2*a2))
    
    x3 = (Fraction(0,1),Fraction(k3.numerator,k3.denominator))
    
    return [x1, x2, x3]

################################################################################

class WeirGroup (object):
    def __init__(self, k2=Fraction(1,1), k3=Fraction(1,1)): 
        #Default group is the one generated by canonical Delta(1,1,1)
        # k1, k2, k3 are fractions
        WeirGroup.k2 = k2
        WeirGroup.k3 = k3
        WeirGroup.k1 = Fraction(k2.denominator*k3.denominator,k2.numerator*k3.numerator)
        
        # The following attributes are shared with JigsawGroup class
        
        WeirGroup.rank = 3     #Generators = number of exterior sides of jigsaw        
        WeirGroup.vertices = [-1,0] #Vertices of triangle are -1,0, inf
        WeirGroup.pts_Y2 = info_rotation_points_Wgrp(self.k1, self.k2, self.k3)
        WeirGroup.generators = generatorsWeirGroup(self.k1,self.k2,self.k3)

        WeirGroup.RotationsToInf = calculateToInf(self.vertices, self.generators)
        
        WeirGroup.L = np.absolute(1 + k3+ k2*k3)    #Length of fundamental interval of group
    
#     def L(self):
#         return self.Length
     
    def print(self):
        print(' ****** print Weirstrass Group ******')
        print( ' ')
        print('This is the Weirstrass group with parmameters k1=',self.k1,', k2=', self.k2,', k3=', self.k3,'.')
        print('Length of fund interval = ', self.L)
        print('Its generators are:')
        print(' ')
        for i in range (0,3):
            print('rotation about', '(' , self.pts_Y2[i][0],',  sqrt(', self.pts_Y2[i][1], ')  ) ' , 'is')
            print('T',i+1, '=')
            printQmtx(self.generators[i])
            print('')
################################################################################
##### Test for WeirGroup class ######
W = WeirGroup(Fraction(1,3),Fraction(3,1))
W.print()


################################################################################
################################################################################

  
def locateQ(x,y,vertices):
# returns k, where 0<=k<=N is the index of the vertex that forms the right endpoint 
# of interval where x/y is. N = len(vertices)
#      k=0         => x/y in [oo,v0]
#      1<=k <= N-1 => x/y in [vk-1,vk]
#      k = N       => x/y in [vN-1, oo]

    N = len(vertices)
    X = np.full(N,Fraction(x,y))
#    print('vertices=',vertices)

    comparison = X<=vertices
    
    lower = np.full(N,1)
    upper = np.full(N,0)
    
    if(comparison == lower).all(): # x is in (inf, v0)
        #print(x,'/',y,'is in [ oo,', vertices[0],']')
        return 0
    if(comparison == upper).all(): # x is in (vN, inf)
        #print(x,'/',y,'is in [', vertices[N-1],',oo]')
        return N     

    k=0
    while(comparison[k] == comparison[k+1]):
        k+=1
    #print(x,'/',y, 'is in [', vertices[k],',',vertices[k+1],']')
    return k+1

################################################################################

print('###### locateQ TEST #######')
k = locateQ(2,33,[-1,0,1])
print('k=',k)   
print('##########################')

################################################################################
################################################################################
def is_cusp(Group, a, maxL, currentL):
    # Checks if a (Fraction type) is a cusp of Jigsawgroup in at most maxL steps
    # To do that it follows the path to a and sees if applying succesive transformations
    # takes a to a vertex of the fundamental domain of JigsawGroup
    # Assumes a !=infinity
    
    if currentL>maxL:
        return False

    currentL +=1 #You will give one more tile a chance
    
    x = a.numerator
    y = a.denominator

    k=locateQ(x,y, Group.vertices)
    
    if(k!= Group.rank-1):   #k=rank => x is bigger than all vertices
                                  # rank of group goes from 1 to N, vertices go from 0 to N-2
        if(a == Group.vertices[k]):  #If you found that x is vertex of the jigsaw
            return True

    M = Group.generators[k]  # generator corresponding to interval x is on
    if(sends2inf(M,a)==True):
        return True
    
    # If it was not a cusp in this step, rotate by M and try again
    
    a = mob_transf(M,a)   
    #print('x transform=', x)
    #print('*************')
    
    return is_cusp(Group,a,maxL,currentL)
    
################################################################################

JG= JigsawGroup([1,2],[1,1])
W = WeirGroup(Fraction(1,3), Fraction(3,1)) # This group has specials 1, 2
#JG.print()

#def is_cusp_word(JigsawGroup, x, maxL, currentL):
print(is_cusp(JG,Fraction(3,1), 2,0)) # Group, rational, iterations, 0
print(is_cusp(W,Fraction(2,1), 2,0)) # Group, rational, iterations, 0)


################################################################################
################################################################################

def check_cusps(Maxden, Group):   
    # Checks if rationals up to denominator MaxDen in the fundamental interval of JigsawGroup
    # are cusps of the JigsawGroup by approximatin by maxL=100 rotations
    
    L = Group.L   # Length of fundamental interval of JG
    maxL = 100            # Maximum number of iterations done to find the cusp
    q=1
    while(q<=Maxden):
        p=0               
        while(p/q <= L ):
            if(bltin_gcd(p, q)==1):
                
                siesonoes = is_cusp(Group, Fraction(p,q), maxL,0) 
                if(siesonoes == False):
                    print('****** CHECK_CUSPS RESULTS ******')
                    print('Bad news...')
                    print('I found', p,'/', q, 'is not a cusp when doing ',maxL,'rotations towards it.')
                    return False
            p+=1
        q+=1
    print('****** CHECK_CUSPS RESULTS ******')
    print('Good news!')
    print('All rationals with denominator at most', Maxden, 'which are less than fund length=', L, 'are cusps!')
    print(' ')
    return True 

################################################################################

JG= JigsawGroup([1,2],[1,1])
W = WeirGroup(Fraction(1,3), Fraction(3,1)) # This group has specials 1, 2

#JG.print()
esonoes = False
#def check_cusps(Maxden, maxL, JigsawGroup)  
check_cusps(50,JG)
check_cusps(10,W)


################################################################################
################################################################################


def IS_CUSP_WORD (Group, a, maxL, currentL, word, M):
    # Checks if a (Fraction type) is a cusp of Jigsawgroup in at most maxL steps
    # RECURSIVE (this is inner function of is_cusp_word)
    #       - currentL, word, M are parameters for the recursion
    # Assumes a !=infinity
    # Returns tuple (True/False, word, a, M), 
    # where - T/F indicates if a is a cusp, 
    #       - M = matrix in group s.t. M(a) = infty
    #       - word is M as word in terms of generators of Group
    #       - a = last number in the iteration 

    
    if currentL>maxL:
        return (False, word, a, M)

    currentL +=1 #You will give one more tile a chance
    
    x = a.numerator
    y = a.denominator

    k=locateQ(x,y, Group.vertices)    
    
    
    if(k!= Group.rank-1):   #k=rank => x is bigger than all vertices
                                  # rank of group goes from 1 to N, vertices go from 0 to N-2
        if(a == Group.vertices[k]):  #If you found that x is vertex of the jigsaw
            word = int(str(Group.RotationsToInf[k][1]) + str(word)) 
            M = multiply(Group.RotationsToInf[k][0],M) # Multiplie by adequate matrix to send to oo
            
            return (True,word, a, M)

    N = Group.generators[k]  # generator corresponding to interval x is on
    
    word = (10**currentL)*(k+1)+word  # Update word and transformation

    M = multiply(N,M)

    if(sends2inf(N,a)==True):
        return (True,word, a, M)
    
    # If it was not a cusp in this step, rotate by M and try again
    a = mob_transf(N,Fraction(x,y))

    return IS_CUSP_WORD(Group,a,maxL,currentL,word,M)

#---------------------------------------------------

def is_cusp_word (Group, a, maxL):
    Id = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
    return IS_CUSP_WORD(Group, a, maxL,0,0,Id)

#---------------------------------------------------

def is_cusp_word_PRINT (Group, a, maxL):
    Id = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
    R= IS_CUSP_WORD(Group, a, maxL,0,0,Id)
    print('--------- is_cusp_word RESULTS ---------')
    if (R[0]==True):
        print('TRUE')
        print(a,' is a cusp, sent to infinity by the element')
        printQmtx(R[3])
        print('word in generators: ',R[1])
    else:
        print('FALSE')
        print('could not determine if', a, 'is a cusp by doing', maxL, 'iterations')
        print('closest approximation:')
        printQmtx(R[3])
        print('word in generators: ',R[1])

    
    return




################################################################################

def explore_cusps(Maxden, Group):
    # Checks all rationals with denominator leq Maxden inside the fundamental interval 
    # of Group to see if they are cusps or not
    # For each rational x it creates a tuple (True/False, word, x, M )
    #   where M(x)= oo and word is the word of M in the generators of Group
    # returns ???

    
    L = Group.L   # Length of fundamental interval of JG
    maxL = 100            # Maximum number of iterations done to find the cusp    

    wordscusps =[]
    Id = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
    q=1
    while(q<=Maxden):
        p=0
        while(p/q <= L ):
            if(bltin_gcd(p, q)==1):     
                word = is_cusp_word(Group, Fraction(p,q), maxL) #,0,0,Id) 
                goodword = (word[0], word[1], Fraction(p,q), word[3]) # is_cusp_word changes the cusp
                wordscusps.append(goodword)
            p+=1
        q+=1
    return wordscusps

################################################################################
def print_explore_cusps(Maxden, Group):
    # Prints the results of explore_cusps
    print('****** explore_cusps RESULTS ******')
    L = Group.L            # Length of fundamental interval of JG
    maxL = 100            # Maximum number of iterations done to find the cusp    
    Id = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
    q=1
    while(q<=Maxden):
        p=0
        while(p/q <= L ):
            if(bltin_gcd(p, q)==1):  
                word = is_cusp_word(Group, Fraction(p,q), maxL)#,0,0,Id) 
                #print(p,'/', q, siesonoes)   
                if(word[0] == False):
                    print('False:   ', p,'/', q, ', approximation = ', word[1])
                else:
                    print('True:   ', p,'/', q, 'is cusp, -> infty by ', word[1])
                
                
            p+=1
        q+=1
        print(' ')
    print(' ')
    return 

################################################################################
################################################################################

JG= JigsawGroup([1,2],[1,1])
W = WeirGroup(Fraction(1,3), Fraction(3,1)) # This group has specials 1, 2


#JG.print()
M = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
printQmtx(M)
is_cusp_word(JG,Fraction(4,1), 8)

V = explore_cusps(2,JG)

print_explore_cusps(3,JG)
print_explore_cusps(3,W)


################################################################################
################################################################################


def check(wordscusps):
    N = len(wordscusps)

    #onlycusps = wordscusps
    onlycusps=[]                      #Only checks if the cusps 
    for i in range(0,N):
        if(wordscusps[i][0] == True):
            onlycusps.append(wordscusps[i])
    
    N= len(onlycusps)   
    for i in range(0,N):

        M = onlycusps[i][3]
        a = onlycusps[i][2]

        if(sends2inf(M,a) == False): #only checks that M(a)=oo

            #if(vertices.count(r) == 0):  #Option to check if M(a) \in vertices
            print('***** message from CHECK in killer intervals *****')
            print('NO GO: ', a , 'is marked as cusp but does not get sent to oo by corresponding matrix.')
            print(' ')
            return False
            #print('***************')
    #print(len(onlycusps))
    #print(len(wordscusps))
    if (len(onlycusps) == len(wordscusps)): 
        #print('***** message from CHECK in killer intervals *****')
        #print('GO! : all the cusps in the list are cusps and matrices correspond.')
        print(' ')
    else:
        #print('***** message from CHECK in killer intervals *****')
        #print('OK : all the elements marked as cusps get set to oo by their matrix, but there were non-cusps in the list')
        print(' ')
    return True

################################################################################
################################################################################

def prepare_matrix(M):
# To compute the killer intervals we need to send a representative of M(oo)=x 
# that has integer entries (3.1). To do so we multiply the entries of M by 
# a common denominator so they are in Z and then reduce them 

    a1=M[0,0].numerator
    b1=M[0,0].denominator

    a2=M[0,1].numerator
    b2=M[0,1].denominator  

    a3=M[1,0].numerator
    b3=M[1,0].denominator
    
    a4=M[1,1].numerator
    b4=M[1,1].denominator
    
    a11 = a1*b2*b3*b4
    a22 = a2*b1*b3*b4
    a33 = a3*b1*b2*b4
    a44 = a4*b1*b2*b3
    
    cdiv = bltin_gcd(a11,a22)
    cdiv = bltin_gcd(cdiv,a33)
    cdiv = bltin_gcd(cdiv, a44)
    
    M00 = Fraction(a11,cdiv)
    M01 = Fraction(a22, cdiv)
    M10 = Fraction(a33, cdiv)
    M11 = Fraction(a44, cdiv)
    
    if M10 < 0:
        M00 = -M00
        M01 = -M01
        M10 = -M10
        M11 = -M11
    
    M = np.matrix( [ (M00, M01), (M10, M11)] )
    return M
################################################################################
################################################################################

def matrix_infty_to_cusp(M):
    # Given that the matrix M sends a known cusp to infinity
    # returns a matrix corresponding to M^(-1) with all coordinates in Z and gcd=1
    # see proposition 3.1 in paper
    
    N = inverseQmatrix(M)
    N = prepare_matrix(N)
    return N
################################################################################
def killing_interval(M):
    # Given a matrix M representing an element in Jigsawgroup, of the form of prop 3.1
    # returns the killer interval (tuple) of the cusp M(oo)=M[0,0]/M[1,0] associated to M 
    
    return ( Fraction(M[0,0] -1, M[1,0]), Fraction(M[0,0]+1,M[1,0]))
    
################################################################################
def generate_killer_intervals(wordscusps):
# wordscusps is an array of the form (True/False, word, a, M)
    # where - T/F indicates if a is a cusp, 
    #       - M = matrix in group s.t. M(a) = infty
    #       - word is M as word in terms of generators of Group
    # coming from function is_cusp_word
# Returns an array where each element is a tuple:
#       (killer_interval, cusp corresponding to killer interval)

    if(check(wordscusps) == False):
        print('******* generate_killer_intervals MESSAGE *******')
        print('Alert! There are false cusps in your array.')
        return
    
    killers = []    

    onlycusps=[]                      # First separates all the cusps from wordscusps
    for i in range(0, len(wordscusps)):
        if(wordscusps[i][0] == True):
            onlycusps.append(wordscusps[i])

    for i in range(0, len(onlycusps)):
        N = inverse(onlycusps[i][3])
        N = prepare_matrix(N)
        killers.append( (killing_interval(N), onlycusps[i][2]) )
    
    return killers

################################################################################
def killer_intervals(maxden, Group):
# Returns an array of tuples, where each element is:
        # (killer_interval, cusp corresponding to killer interval)
# Cusps of Group are calculated up denominator maxden.
# (old tell_killer_intervals)

    # Max#iterations to find cusps = 100 (defined @ explore_cusps)
    V = explore_cusps(maxden, Group) #maxden, maxL, group
    return generate_killer_intervals(V)

################################################################################
################################################################################

def print_killer_intervals(maxden, Group):
# Prints cusps and corresponding killer intervals of Group (up to denominator maxden)
# return is void.
    
    # Max#iterations to find cusps = 100 (defined @ explore_cusps)
    V = explore_cusps(maxden, Group) 
    
    killers = generate_killer_intervals(V)
    print('')
    
    intervals = []
    for i in range (0, len(killers)):
        intervals.append( killers[i][0])

    for i in range (0, len(killers)):
        print('killer around ', killers[i][1], ':')
        print(intervals[i][0],',',intervals[i][1])
        print(' ')
            
    return

#####################################################################

# *****  Calculate killer intervals for all the cusps found among 
# *****  the rationals up tp denominator Maxden (first parementer)
JG= JigsawGroup([1,2],[1,1])
print_killer_intervals(2,JigsawGroup)

################################################################################
################################################################################
def do_intervals_cover(x,y, cusps, Xend,Yend,  cover):
# if possible, finds a subcollection of given intervals that covers [Xend, Yend]
# x,y are arrays with endpoints of opencover
# [Xend, Yend] is the interval you are trying to cover
# cover has to be externally initialized to []
# if cover covers: returns subcover that covers
#          else: returns False
#previous does_cover_cover4

    checkX = []     # Find all intervals that contain Xend of interval
    checkY = []
    checkCusp = []
    
    # Method 1: when Xend is cusp of Group

    # if X end is cusp and endpoint of some open in cover    
    if(Xend in cusps and Xend in x ):   
        
        # Add killer interval of the cusp to cover
        k = cusps.index(Xend)            
        cover.append((x[k], y[k], cusps[k])) 
        if(y[k]>Yend):  # If that interval covers, finish
            return cover
        
        # Look for the cusps that have Xend as x-endpt of their killer interval
        for i in range (0, len(x)):
            if(Xend==x[i] and y[k]<y[i]):
                checkX.append(x[i])
                checkY.append(y[i])
                checkCusp.append(cusps[i])
        if(len(checkX) == 0):   
            Xend = y[k]        
    
    
    # Method 2: if Xend not a (known) cusp of Group
    else:
        
        for i in range (0,len(x)):      # Find all intervals that contain Xend of interval
            if(x[i]<Xend and Xend<y[i]):
                checkX.append(x[i])
                checkY.append(y[i])
                checkCusp.append(cusps[i])

        if(len(checkX) == 0):   # The cover doesn't cover Xend of interval
            print(' ****** do_intervals_cover RESULTS ****** ')
            print('did not cover', Xend)
            return False
    
        # From the intervals that contain Xend, find the one that covers the most 
    
    if(len(checkX)!=0):
        maxi = 0    
        for i in range (1,len(checkY)):
            if(checkY[i]>checkY[i-1]):
                maxi=i
        cover.append((checkX[maxi], checkY[maxi], checkCusp[maxi]))
        

        if(checkY[maxi]> Yend): # That intervals covers!
            return cover
    
        Xend = checkY[maxi]    # Construct new interval and new cover
    
    
    newx = []
    newy = []
    newcusps = []
    for i in range(0,len(y)):  # Only keep the opens that have a chance of covering remainin interval
        if(y[i]>Xend):
            newx.append(x[i])
            newy.append(y[i])
            newcusps.append(cusps[i])
    
    return do_intervals_cover( newx, newy, newcusps, Xend,Yend, cover)

################################################################################
################################################################################

def check_cover(x,y, Xend, Yend):
# Checks if the cover given by do_intervals_cover indeed covers interval [Xend,Yend]
    if(x[0]> Xend):
        return False
    if(y[len(y)-1]< Yend):
        return False

    for i in range (0,len(x)-1):
        if y[i]<x[i+1]:   #there is a gap between intervals
            return False
    return True

    ################################################################################
################################################################################

def cover_with_killers(Group,maxden):
# checks if the collection of killer intervals corresponding to cusps in Group 
# (up to denom maxden) cover the fundamenta interval of the Group
# It also prints the results
# ... can be altered to return : False if it intervals don't cover
#           cover (subcollection of killer intervals) that cover ...

    
#previous cover_with_killers4
    
    # Generates killer intervals for all cusps with den<=maxden
    killers = killer_intervals(maxden, Group)  
    
    # Separate intervals and cusps
    intervals = []
    cusps = []
    for i in range (0, len(killers)):
        intervals.append( killers[i][0])
        cusps.append(killers[i][1])

    # Separate x and y ends of intervals
    x = []
    y = []
    for i in range(0, len(intervals)):
        x.append(intervals[i][0])
        y.append(intervals[i][1])

    # See if the killer interval collection covers
    cover = do_intervals_cover(x,y, cusps, 0,Group.L, [])
    if( cover == False):
        print(' ****** cover_with_killers RESULTS ****** ')
        print('Bad news...')
        print('The cover generated by the cusps found in group does not cover the fundamental interval.')
        print(' ')
        return 
    
    # Double check the cover covers
    x=[]
    y=[]
    for i in range(0, len(cover)):
        x.append(cover[i][0])
        y.append(cover[i][1])
    siono = check_cover(x, y, 0, Group.L)
    
    if(siono == True):
        print(' ****** cover_with_killers RESULTS ****** ')
        print('Good news!')
        print('The cover generated by the cusps found among rationals with denominator at most', maxden,'covers the fundamental interval [0,', Group.L,'].')
        print('The cover has', len(cover),' intervals:')
        for i in range(0, len(cover)):
            print(cover[i][2] ,' ---' , cover[i][0], ' , ', cover[i][1]   )
        print(' ')
        return 
    print(' ****** cover_with_killers RESULTS ****** ')
    print('Bad news...')
    print('The program computed a false cover.')
    print(' ')
    return 

#####################################################################
#####################################################################
######## everything that can be done with the previous code #########

# *****   generate a jigsaw group ***** #
JG= JigsawGroup([1,4],[1,2])
print('fundamental interval = [0,', JG.L,']')
JG.printNOGENS()

# ***** generate a Weirstrass group *****



# *****  check if rationals up to denominator Maxden are cusps  ***** #
# *****  for a given rational stops after 100 iterations ****** #
#esonoes = False
#def check_cusps(Maxden, maxL, JigsawGroup)  
#check_cusps(20,50,JG)



# *****  check if rationals up to denominator Maxden are cusps  ***** #
# *****  for a given rational stops after 100 iterations ****** #
#print_check_cusps(20,50,JG)
#print(' ')


# *****  Calculate killer intervals for all the cusps found among 
# *****  the rationals up tp denominator Maxden (first parementer)
#JG= JigsawGroup([1,3],[1,1])
#print_killer_intervals(2,JigsawGroup)
cover_with_killers(JG, 7)

##AQUI

#W2 = WeirGroup(Fraction(3,2),Fraction(2,5))
#cover_with_killers(W2, 10)

#W6 = WeirGroup(Fraction(9,5),Fraction(5,7))
#cover_with_killers(W6, 50)

#####################################################################
#####################################################################

# -------------------------------------------------------------------------------
# ------------ THIS SECTION OF THE CODE DEALS WITH FINDING SPECIALS -------------
# -------------------------------------------------------------------------------

def look_for_wholes(Group, maxL):
# Tries to build a cover with killer intervals whose endpoints are cusps, 
# starting with the killer interval around 0.
# if at some stage it cannot continue, it returns the number that could not be
# determined to be a cusp.

    L = Group.L
    x = 0
    Id = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
    k=0
#    maxL=1000
    
    Yends = []

    while( x< L and k<maxL):
               #is_cusp_word(Group, a, maxL, currentL, word, M):
        info = IS_CUSP_WORD(Group, x, maxL, 0,0, Id ) # has form (T/F, word, cusp, M)
        
        if(info[0]== False):
            print(' ***** look_for_wholes RESULTS ***** ')
            print(x, 'is not a cusp of the group (up to', maxL ,' rotations)')
            print('An approximation to it is', info[1])
            print(' ')
            return
        
        k_interval = generate_killer_intervals([(info[0], info[1], x, info[3])]) 
        # has form [(endX,endY) , cusp]
        
        # Take left end of killer interval around x and repeat process
        x= k_interval[0][0][1]   
        Yends.append(x)
        k+=1
        
    if(k == maxL):
        print(' ***** look_for_wholes RESULTS ***** ')
        print('Did not cover the interval. Endpoints were:')
        for i in range (0, len(Yends)):
            print(Yends[i])
        print(' ')
        return 
    if( x>= L):
        print(' ***** look_for_wholes RESULTS ***** ')
        print('A cover was generated!')
        print(' ')
        return

    
# -------------------------------------------------------------------------------



W = WeirGroup(Fraction(1,3), Fraction(3,1)) # This group has specials 1, 2
look_for_wholes(W,200)

#W = WeirGroup(Fraction(2,5), Fraction(5,7)) # This group has specials 1, 2
# look_for_wholes(W,1755)

################################################################################
################################################################################

def word2mtx(Group, word):
# word is a sequence of digits where each represents a generator in the group.
# retunrs the matrix X corresponding to this word

    if word % 10 == 0:
        word = Fraction(word, 10)
    L = len(str(word)) # !!! assumes each digit represents a generator
    X = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
    for i in range(0,L):
        k = int(word % 10)
        X = multiply(X,Group.generators[k-1])
        word = Fraction(word - k,10)
    return X

################################################################################
def subword2mtx(Group, word, i, j):    
    # Returns (subword, M) where 
    #       - subword = subword of word going from the i-th digit to the j-th (including both)
    #       - M = transformation corresponding to subword according to Group.generators
    out = word % (10**i)
    word = word % (10**j) - out
    word = Fraction(word, 10**i)
    
    M = word2mtx(Group, word)
    
    return (word,M)

def conjugate_word(Group, word, subword, j):
    # Conjugates subword by the first j digits of word
    # Returns tuple (conjugated_word, M) where 
    #   - M= matrix corresponding to conjugated_word according to Group.generators
    
    for i in range(0, j):
        k = int(word % 10)       # !!! Only work for at most 9 generators. (8 tiles)
        subword = int( str(k) + str(subword) + str(k))
        word = Fraction(word - k,10)
    
    return(subword, word2mtx(Group, subword))
    
    

################################################################################
def check_special(Group, a,maxL):
# Given a (rational type), the function tries to determine if it is a special for Group
# maxL = max number of iterations allowed
# prints results
    

    #maxL=400  #digits in word
    Id = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
    
    info = IS_CUSP_WORD(Group, a, maxL, 0,0, Id )
    word = int(Fraction(info[1], 10))  # Adjust because words always have 0 at the beginning.
    
    # If a is a cusp, finish.
    if(info[0] == True):
        print(' ****** check_special RESULTS ******')
        print('This is a cusp! :', a)
        print('Sent to oo by:')
        printQmtx(info[3])
        print('its word has length ',len(str(word)),'and it is:', word)
        print('  ')
        return 

    
    woord = word  # Need a copy because word is going to get destroyed
    orbit = [a]
    distinct = True
    i = 0
    
    while( distinct==True and i<maxL):
        k = int(word % 10)       # !!! Only works for at most 9 generators. (less than 8 tiles)
        M = Group.generators[k-1]
        
        newpoint = mob_transf(M, orbit[i])

        # Check if you are returning to newpoint
        if( newpoint in orbit): 
            j=0
            while(orbit[j]!= newpoint):
                j+=1
            # Have to conjugate the word of the first special found to get the word for a
                #subword = (word, matrix)
            subword = subword2mtx(Group, woord, j, i+1) #element in group that fixes element orbit[j]=orbit[i]
            subword = conjugate_word(Group, woord, subword[0], j) # Conjugates subword by the first j digits of word
                        
            print(' ****** check_special RESULTS ******')
            print(i,':',newpoint,'= first appearance',j,':',orbit[j])
            print('This is a special:', a)
            print('Fixed by Mobius transf=')
            printQmtx(subword[1])
            trace= tr(subword[1])*tr(subword[1])/det(subword[1])
            print('as en element in PSL(2,R) this has trace',trace )
            if np.absolute(trace)>4:
                print('     hyperbolic')
            if np.absolute(trace)<4:
                print('     elliptic')
            if np.absolute(trace)==4:
                print('      parabolic')
            print('its word has length ',len(str(subword[0])) ,' and it is', subword[0])      
            print('   ')
            return 
        
        orbit.append(newpoint)
        word = Fraction(word - k,10)
        i+=1

    if i== maxL:
        print(' ****** check_special RESULTS ******')
        print('Could not determine if',a,' is a cusp or a special. (', maxL,' steps)')
        print(' ')
        return 

################################################################################
################################################################################
#W3 = WeirGroup(Fraction(1,3), Fraction(3,1)) # This group has specials 1, 2
#check_special(W3, Fraction(1,1),10)
#check_special(W3, Fraction(2,1),10)

#AAAA

W = WeirGroup(Fraction(1,3), Fraction(3,1)) # This group has specials 1, 2
W.print()
check_special(W, Fraction(1,1),80)

################################################################################
################################################################################

# -------------------------------------------------------------------------------
# ------- THIS SECTION OF THE CODE DEALS WITH TILING THE VERTICAL STRIPE --------
# -------------------------------------------------------------------------------


def calculate_side_types(n, k):
    # n = type of the triangle
    # k = how many vertices on x-axis
    # returns an array sidetypes, where sidetypes[i] is the type of the side 
    # from the i-th vertex to the (i+1)-vertex. 
    # First vertex is assumed to be oo and then goes in CCW. 
    
    sidetypes = [1,1]  # Jigsaw always has first tile type Delta(1,1,1)
    for i in range (0,k-2):
        if(i%3 == 0):
            sidetypes.append(3)  # 3 = 1/n
        if (i%3 == 1):
            sidetypes.append(1) # 1 = 1
        if(i%3 == 2):
            sidetypes.append(2)  # 2 = n      
    # Vertical side from last vertex to infty
    if ( sidetypes[k-1] == 1):
        sidetypes.append(3)
    if ( sidetypes[k-1] == 2):
        sidetypes.append(1)
    if ( sidetypes[k-1] == 3):
        sidetypes.append(2)
    
    return sidetypes

def cover_by_vertical_rotations(Group):
# Returns list of vertices of the tiling (given by Group)
#  that have a vertex on the fundamental interval
    
    sidetype = calculate_side_types(Group.sign[1], len(Group.vertices))
    vertices = list(Group.vertices)
    cusps = list(Group.vertices)  # Where we save all the generated non-oo cusps.
    vertices.insert(0, "INF")  # now sydetipe[i] = sidetype from vertices[i] to vertices[i+1]
    
    L = Group.L #length of fund interval
    numV = len(vertices)
    k = numV-1
    largest = vertices[k]
    
    n = Group.tiles[1]

    while(largest < L ):
    # calculate rotation about [largest, oo], take side type into account
        if (sidetype[k] == 1):
            R = pi_rotation_special(largest, 1)
        else:
            R = pi_rotation_special(largest, n) # propostion 4.3 5)
        for i in range (0,len(vertices)):
            a = vertices.pop(numV-1)
            x = mob_transf(R, a)
            vertices.insert(0,x)
            if ( i!= numV-k-1):
                cusps.append(x)
        largest = max(cusps)
        k = vertices.index(largest)
        
        cusps = sorted(set(cusps))
    return cusps
     
############################################################################
JG = JigsawGroup([1,4],[1,3])
print('length of fund interval: ', JG.L)
C = cover_by_vertical_rotations(JG)
for i in range(0, len(C)):
    print(C[i])


#is_cusp(JG, Fraction(10,1), 3, 0)


############################################################################
############################################################################
############################################################################


#cells with examples of code usage


############################################################################
############################################################################
############################################################################


################################################################################
def find_special_in_orbit(Group, a,maxL):
# Given a (rational type), the function tries to determine if there is a special in the orbit of a
# orbit is calculated ....
# maxL = max number of iterations allowed
# prints results
    

    #maxL=400  #digits in word
    Id = np.matrix( [ (Fraction(1),Fraction(0))  , (Fraction(0), Fraction(1)) ] )
    
    info = IS_CUSP_WORD(Group, a, maxL, 0,0, Id )
    word = int(Fraction(info[1], 10))  # Adjust because words always have 0 at the beginning.
    
    # If a is a cusp, finish.
    if(info[0] == True):
        print(' ****** check_special RESULTS ******')
        print('This is a cusp! :', a)
        print('Sent to oo by:')
        printQmtx(info[3])
        print('its word has length ',len(str(word)),'and it is:', word)
        print('  ')
        return 

    
    woord = word  # Need a copy because word is going to get destroyed
    orbit = [a]
    distinct = True
    i = 0
    
    while( distinct==True and i<maxL):
        k = int(word % 10)       # !!! Only works for at most 9 generators. (less than 8 tiles)
        M = Group.generators[k-1]
        
        newpoint = mob_transf(M, orbit[i])

        # Check if you are returning to newpoint
        if( newpoint in orbit): 
            j=0
            while(orbit[j]!= newpoint):
                j+=1
            # Have to conjugate the word of the first special found to get the word for a
                #subword = (word, matrix)
            subword = subword2mtx(Group, woord, j, i+1) #element in group that fixes element orbit[j]=orbit[i]
            
            print(' ****** check_special RESULTS ******')
            print('This is a special:', a)
            print(i,':',newpoint,' first appearance =',j,':',orbit[j])
            print(orbit[j], 'fixed by Mobius transf=')
            printQmtx(subword[1])
            trace= tr(subword[1])*tr(subword[1])/det(subword[1])
            print('as en element in PSL(2,R) this has trace',trace )
            if np.absolute(trace)>4:
                print('     hyperbolic')
            if np.absolute(trace)<4:
                print('     elliptic')
            if np.absolute(trace)==4:
                print('      parabolic')
            print('its word has length ',len(str(subword[0])) ,' and it is', subword[0])      
            print('   ')
            return subword[1]
        
        orbit.append(newpoint)
        word = Fraction(word - k,10)
        i+=1

    if i== maxL:
        print(' ****** check_special RESULTS ******')
        print('Could not determine if',a,' is a cusp or a special. (', maxL,' steps)')
        print(' ')
        return 



################################################################################
################################################################################
def fixpts (M):  # this does not work, use fixpts2 in "workspace looking for specials"
    
    d= det(M)  #checkpoint
    if d!= 1:
        if d!= -1:
            print('matrix is not in PSL(2,R)')
            return
#    if d==-1:
#        M=-1*M
    
    a3=M[1,0].numerator
    b3=M[1,0].denominator
    
    if a3==0: #** fill this
        return
        
    a1=M[0,0].numerator
    b1=M[0,0].denominator

    a4=M[1,1].numerator
    b4=M[1,1].denominator
    
    disD = (a1**2)*(b4**2) +2*a1*a4*b1*b4 + (a4**2)*(b1**2)-4*(b1**2)*(b4**2) #denominator of discriminant

    if disD == 0:
        print('parabolic element')
        #fill this
        return     
    
    if disD <0:
        print('elliptic element')
        #fill this
        return 


    disN = (b1**2)*(b4**2) #numerator of discriminant
    init = Fraction(a1*b4-a4*b1,b1*b4)
    div = Fraction(b3,2*a3)

    
    rootD = int(math.sqrt(disD))
    if (rootD**2 == disD):
        
        rootN = int(math.sqrt(disN))
        if (rootN**2 == disN):        
        
            disc = Fraction(rootD, rootN)
            root1 = (init + disc)*div #all these are fraction type
            root2 = (init - disc)*div
            print('Fixed pts (calculated exactly):')
            print(root1, ' , ',root2)
            return [root1, root2]
    disc= math.sqrt(Fraction(disD,disN))
    root1 = (init + disc)*div
    root2 = (init - disc)*div    
    print('Fixed pts (float approximation):')
    print(root1, ' , ',root2)
    
    return [root1, root2]

